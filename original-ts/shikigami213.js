//
// shikigami213.js
// SHIKIGAMI 2.1.3 -Help Tool for Helio Compass Drawing-
// Copyright(C)2021 T.Takao@Will System Design All Rights Reserved.
// https://will-system.net/
//

const svgWidth = 1683.7795;
const svgHeight = 2383.937;
const svgLeft = 841.8896;
const svgTop = 1191.9687;
const svgLineWidth = 0.25;
const svgAuR = 424.0488; // 1AU = 424.0488px
const whiteColor = '#FFFFFF';
const blackColor = "#000000";
const redColor = '#FF0000';
const greenColor = '#33CC33';

let svg;

function downloadSVG() {
  svg.download();
}

// SHIKIGAMIメインルーチン
function shikigami(o, flagDraw, drawTime) {
  let svgImage;
  let flagSunrise, flagSunset;
  let flagDay, flagNight;
  let flagDrawTime;

  svg = new Svg(o.initDt, svgWidth, svgHeight, svgLeft, svgTop);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);

  svg.groupId(`ガイド基準`);

  svg.groupId(`中心点`);
  svg.circle(0, 0, 1.723, svgLineWidth, blackColor, whiteColor, 0);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, 583.54395, 0, svgLineWidth, redColor);
  svg.groupFooter();

  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw[10];
  flagSunset = flagDraw[11];
  flagDay = flagDraw[12];
  flagNight = flagDraw[13];

  // 描画基準時刻設定
  if (drawTime === 'noon') {
    flagDrawTime = true;
  } else {
    flagDrawTime = false;
  }

  // 惑星描画
  if (flagDraw[0]) { drawSun(o, flagSunrise, flagSunset, flagDay, flagNight, flagDrawTime); }
  if (flagDraw[1]) { drawMoon(o, flagDrawTime); }
  if (flagDraw[2]) { drawMercury(o, flagDrawTime); }
  if (flagDraw[3]) { drawVenus(o, flagDrawTime); }
  if (flagDraw[4]) { drawMars(o, flagDrawTime); }
  if (flagDraw[5]) { drawJupiter(o, flagDrawTime); }
  if (flagDraw[6]) { drawSaturn(o, flagDrawTime); }
  if (flagDraw[7]) { drawUranus(o, flagDrawTime); }
  if (flagDraw[8]) { drawNeptune(o, flagDrawTime); }
  if (flagDraw[9]) { drawPluto(o, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${svgHeight - 210})">描画開始日：${o.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${svgHeight - 180})">描画場所：${o.name}　経度 ${o.longitude} / 緯度 ${o.latitude} / タイムゾーン UTC+${o.timezone}</text>`);

  if (flagDrawTime) {
    svg.tag(`<text transform="translate(100,${svgHeight - 150})">描画基準時刻：正午／正子</text>`);
  }
  else {
    svg.tag(`<text transform="translate(100,${svgHeight - 150})">描画基準時刻：南中／北中</text>`);
  }

  svg.tag(`<text transform="translate(100,${svgHeight - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();

  svg.end();

  svgImage = document.getElementById('svgImage');
  svgImage.innerHTML = svg.string;
}

// 地球（太陽）
function drawSun(o, flagSunrise, flagSunset, flagDay, flagNight, flagDrawTime) {
  const svgInR = 416.9622, svgOutR = 431.13545;
  const svgLineR = 583.54395;
  const svgDaysR = 433.22035;
  const svgSize = 1.723;
  const strokeColor = '#231815';
  const guideSunriseColor = '#FF9900', guideSunsetColor = '#CC6600';
  let startDt, endDt, rotateDays;
  let drawDt;
  let suntime;
  let mjd, t;
  let sun, sunrise, sunset;
  let sunDateLine = [], sunriseLine = [], sunsetLine = [];
  let sunBall = [], sunNumber = [];
  let daysAngle, offsetR;
  let d;

  // 1周の描画数を決める（日数）
  startDt = new Date(o.initDt);
  endDt = new Date(o.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateDays = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60 * 24);

  // 最初の夜起点要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);

  // 正子にするか北中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.initDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.northDt, o.timezone);
  }
  t = Astro.t(mjd);
  sun = new Sun(t);

  // 日付線
  // 正子にするか北中にするか選ぶ
  if (flagDrawTime) {
    sunDateLine[1] = [suntime.initDt.toLocaleString(), sun.r, sun.y];
  } else {
    sunDateLine[1] = [suntime.northDt.toLocaleString(), sun.r, sun.y];
  }

  // 日の出線
  mjd = Astro.mjd(suntime.sunriseDt, o.timezone);
  t = Astro.t(mjd);
  sunrise = new Sun(t);
  sunriseLine[1] = [suntime.sunriseDt, sunrise.r, sunrise.y];

  // 日の入り線
  mjd = Astro.mjd(suntime.sunsetDt, o.timezone);
  t = Astro.t(mjd);
  sunset = new Sun(t);
  sunsetLine[1] = [suntime.sunsetDt, sunset.r, sunset.y];


  // 最終までの夜起点要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);

    // 正子にするか北中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.initDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.northDt, o.timezone);
    }
    t = Astro.t(mjd);
    sun = new Sun(t);

    // 日付線
    // 正子にするか北中にするか選ぶ
    if (flagDrawTime) {
      sunDateLine[d] = [suntime.initDt.toLocaleString(), sun.r, sun.y];
    } else {
      sunDateLine[d] = [suntime.northDt.toLocaleString(), sun.r, sun.y];
    }

    // 日の出線
    mjd = Astro.mjd(suntime.sunriseDt, o.timezone);
    t = Astro.t(mjd);
    sunrise = new Sun(t);
    sunriseLine[d] = [suntime.sunriseDt, sunrise.r, sunrise.y];

    // 日の入り線
    mjd = Astro.mjd(suntime.sunsetDt, o.timezone);
    t = Astro.t(mjd);
    sunset = new Sun(t);
    sunsetLine[d] = [suntime.sunsetDt, sunset.r, sunset.y];
  }

  // 最初の昼起点要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  sun = new Sun(t);

  // 地球玉
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    sunBall[1] = [suntime.noonDt.toLocaleString(), sun.r, sun.y];
  } else {
    sunBall[1] = [suntime.southDt.toLocaleString(), sun.r, sun.y];
  }

  // 通日ラベル
  if (sun.y >= 180) {
    daysAngle = 270 - sun.y;
    offsetR = 2.25;
  } else {
    daysAngle = 90 - sun.y;
    offsetR = 0;
  }

  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    sunNumber[1] = [suntime.noonDt.toLocaleString(), offsetR, sun.y, daysAngle];
  } else {
    sunNumber[1] = [suntime.southDt.toLocaleString(), offsetR, sun.y, daysAngle];
  }

  // 最終までの昼起点要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    sun = new Sun(t);

    // 地球玉
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      sunBall[d] = [suntime.noonDt.toLocaleString(), sun.r, sun.y];
    } else {
      sunBall[d] = [suntime.southDt.toLocaleString(), sun.r, sun.y];
    }

    // 通日ラベル
    if (sun.y >= 180) {
      daysAngle = 270 - sun.y;
      offsetR = 2.25;
    } else {
      daysAngle = 90 - sun.y;
      offsetR = 0;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      sunNumber[d] = [suntime.noonDt.toLocaleString(), offsetR, sun.y, daysAngle];
    } else {
      sunNumber[d] = [suntime.southDt.toLocaleString(), offsetR, sun.y, daysAngle];
    }
  }

  // ここから地球SVG生成
  svg.groupId(`地球`);

  svg.groupId(`日付線`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`日付線 ${sunDateLine[1][0]}`);
  svg.line(svgAuR * sunDateLine[1][1], sunDateLine[1][2], svgLineR, sunDateLine[1][2], svgLineWidth, greenColor);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`日付線 ${sunDateLine[d][0]}`);
    svg.line(svgAuR * sunDateLine[d][1], sunDateLine[d][2], svgLineR, sunDateLine[d][2], svgLineWidth, strokeColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  if (flagSunrise) {
    svg.groupId(`日の出線`);
    for (d = 1; d <= rotateDays; d++) {
      // ここでsuntime.sunriseDtを判定に使うので、文字列化はそのあとで
      if (flagSunrise && !isNaN(sunriseLine[d][0].getTime())) {
        svg.groupId(`日の出線 ${sunriseLine[d][0].toLocaleString()}`);
        svg.line(svgAuR * sunriseLine[d][1], sunriseLine[d][2], svgLineR, sunriseLine[d][2], svgLineWidth, guideSunriseColor);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagSunset) {
    svg.groupId(`日の入り線`);
    for (d = 1; d <= rotateDays; d++) {
      if (!isNaN(sunsetLine[d][0].getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`日の入り線 ${sunsetLine[d][0].toLocaleString()}`);
        svg.line(svgAuR * sunsetLine[d][1], sunsetLine[d][2], svgLineR, sunsetLine[d][2], svgLineWidth, guideSunsetColor);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagDay) {
    svg.groupId(`昼エリア`);

    for (d = 1; d <= rotateDays; d++) {
      if (!isNaN(sunriseLine[d][0].getTime()) && !isNaN(sunsetLine[d][0].getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`昼エリア ${sunriseLine[d][0].toLocaleString()} ${sunsetLine[d][0].toLocaleString()}`);
        svg.area(svgAuR * sunriseLine[d][1], sunriseLine[d][2], svgAuR * sunsetLine[d][1], sunsetLine[d][2], svgLineR, svgLineWidth, guideSunriseColor, `none`);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagNight) {
    svg.groupId(`夜エリア`);

    // 最終の夜エリアは開始日の日の出時間につなぐ
    for (d = 1; d <= rotateDays - 1; d++) {
      if (!isNaN(sunriseLine[d + 1][0].getTime()) && !isNaN(sunsetLine[d][0].getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`夜エリア ${sunsetLine[d][0].toLocaleString()} ${sunriseLine[d + 1][0].toLocaleString()}`);
        svg.area(svgAuR * sunriseLine[d + 1][1], sunriseLine[d + 1][2], svgAuR * sunsetLine[d][1], sunsetLine[d][2], svgLineR, svgLineWidth, guideSunsetColor, `none`);
        svg.groupFooter();
      }
    }

    if (!isNaN(sunsetLine[rotateDays][0].getTime())) {
      // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
      svg.groupId(`夜エリア ${sunsetLine[rotateDays][0].toLocaleString()} 描画開始日の日の出日時`);
      svg.area(svgAuR * sunriseLine[1][1], sunriseLine[1][2], svgAuR * sunsetLine[rotateDays][1], sunsetLine[rotateDays][2], svgLineR, svgLineWidth, guideSunsetColor, `none`);
      svg.groupFooter();
    }
    svg.groupFooter();
  }

  svg.groupId(`地球玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`地球玉 ${sunBall[1][0]}`);
  svg.circle(svgAuR * sunBall[1][1], sunBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`地球玉 ${sunBall[d][0]}`);
    svg.circle(svgAuR * sunBall[d][1], sunBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`通日ラベル`);
  for (d = 1; d <= rotateDays; d++) {
    svg.groupId(`通日ラベル${('000' + d).slice(-3)} ${sunNumber[d][0]}`);
    svg.text('days', svgDaysR + sunNumber[d][1], sunNumber[d][2], sunNumber[d][3], ('000' + d).slice(-3));
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`地球移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`地球移動線 ${sunBall[d][0]}`);
    svg.line(svgAuR * sunBall[d - 1][1], sunBall[d - 1][2], svgAuR * sunBall[d][1], sunBall[d][2], svgLineWidth, blackColor);
    svg.groupFooter();
  }

  svg.groupId(`地球移動線 閉じる`);
  svg.line(svgAuR * sunBall[rotateDays][1], sunBall[rotateDays][2], svgAuR * sunBall[1][1], sunBall[1][2], svgLineWidth, blackColor);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`地球近点軌道`);
  svg.circle(0, 0, svgInR, svgLineWidth, redColor, `none`);
  svg.groupFooter();

  svg.groupId(`地球遠点軌道`);
  svg.circle(0, 0, svgOutR, svgLineWidth, redColor, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 月
function drawMoon(o, flagDrawTime) {
  const svgSmallSize = 0.4;
  const svgBigSize = 2.601;
  const strokeColor = '#231815';
  const fullmoonColor = '#FCC800', newmoonColor = '#3e3a39';
  let startDt, endDt, rotateHours;
  let drawDt;
  let suntime;
  let mjd, t;
  let sun, moon;
  let moonBall = [], fullmoonBall = [], newmoonBall = [];
  let angleCos;
  let pre1sun, pre1moon, pre1Dt, pre1Cos, pre1R, pre1Y, pre2Cos;
  let d;

  // 1周の描画数を決める（日数×6時間毎）
  startDt = new Date(o.initDt);
  endDt = new Date(o.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateHours = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60) / 6;

  // 最初の夜起点要素
  suntime = new Suntime(o.initDt, o.longitude, o.latitude, o.timezone);
  // 正子にするか北中にするか選ぶ
  if (flagDrawTime) {
    drawDt = new Date(suntime.initDt);
  } else {
    drawDt = new Date(suntime.northDt);
  }

  // 月波
  mjd = Astro.mjd(drawDt, o.timezone);
  t = Astro.t(mjd);
  sun = new Sun(t);
  moon = new Moon(t);
  angleCos = -Math.cos((moon.y - sun.y) * RAD);
  moonBall[1] = [drawDt.toLocaleString(), sun.r, angleCos, sun.y];

  // 1点前の位置を取得
  pre1Dt = new Date(drawDt);
  pre1Dt.setHours(pre1Dt.getHours() - 6);
  mjd = Astro.mjd(pre1Dt, o.timezone);
  t = Astro.t(mjd);
  pre1sun = new Sun(t);
  pre1moon = new Moon(t);
  pre1Cos = -Math.cos((pre1moon.y - pre1sun.y) * RAD);

  // 1点前と2点前の位置を更新
  pre2Cos = pre1Cos;
  pre1Dt = new Date(drawDt);
  pre1R = sun.r;
  pre1Cos = angleCos;
  pre1Y = sun.y;

  // 最終までの夜起点要素ループ
  // 開始点から6時間毎なのでdrawDtでインクリメントする。suntimeは不要
  for (d = 2; d <= rotateHours; d++) {
    drawDt.setHours(drawDt.getHours() + 6);

    // 月玉
    mjd = Astro.mjd(drawDt, o.timezone);
    t = Astro.t(mjd);
    sun = new Sun(t);
    moon = new Moon(t);
    angleCos = -Math.cos((moon.y - sun.y) * RAD);
    moonBall[d] = [drawDt.toLocaleString(), sun.r, angleCos, sun.y];

    // 2点前の離角余弦＜1点前の離角余弦＞現在の離角余弦（山）なら1点前を満月とする
    if (pre2Cos < pre1Cos && pre1Cos > angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      fullmoonBall.push([pre1Dt.toLocaleString(), pre1R, pre1Cos, pre1Y]);
    }

    // 2点前の離角余弦＞1点前の離角余弦＜現在の離角余弦（谷）なら1点前を新月とする
    if (pre2Cos > pre1Cos && pre1Cos < angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      newmoonBall.push([pre1Dt.toLocaleString(), pre1R, pre1Cos, pre1Y]);
    }

    // 1点前と2点前の位置を更新
    pre2Cos = pre1Cos;
    pre1Dt = new Date(drawDt);
    pre1R = sun.r;
    pre1Cos = angleCos;
    pre1Y = sun.y;
  }

  // ここから月SVG生成
  svg.groupId(`月`);

  svg.groupId(`月波`);
  // 1日目だけ描画色を変えるのでループ分け
  svg.groupId(`月波 ${moonBall[1][0]}`);
  svg.circle(moonBall[1][1] * svgAuR * (1 + moonBall[1][2] / 20), moonBall[1][3], svgSmallSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateHours; d++) {
    svg.groupId(`月波 ${moonBall[d][0]}`);
    svg.circle(moonBall[d][1] * svgAuR * (1 + moonBall[d][2] / 20), moonBall[d][3], svgSmallSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`満月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (d = 0; d <= fullmoonBall.length - 1; d++) {
    svg.groupId(`満月玉 ${fullmoonBall[d][0]}`);
    svg.circle(fullmoonBall[d][1] * svgAuR * (1 + fullmoonBall[d][2] / 20), fullmoonBall[d][3], svgBigSize, svgLineWidth, strokeColor, fullmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`新月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (d = 0; d <= newmoonBall.length - 1; d++) {
    svg.groupId(`新月玉 ${newmoonBall[d][0]}`);
    svg.circle(newmoonBall[d][1] * svgAuR * (1 + newmoonBall[d][2] / 20), newmoonBall[d][3], svgBigSize, svgLineWidth, strokeColor, newmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupFooter();
}

// 水星
function drawMercury(o, flagDrawTime) {
  const svgInR = 130.3795, svgOutR = 197.8724;
  const svgSize = 0.69;
  const strokeColor = '#231815';
  const rotateDays = 88;
  let drawDt;
  let suntime;
  let mjd, t;
  let mercury;
  let mercuryBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  mercury = new Mercury(t);

  // 水星玉
  compassY = mercury.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mercuryBall[1] = [suntime.noonDt.toLocaleString(), mercury.r, compassY];
  } else {
    mercuryBall[1] = [suntime.southDt.toLocaleString(), mercury.r, compassY];
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);

    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    mercury = new Mercury(t);

    // 水星玉
    compassY = mercury.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mercuryBall[d] = [suntime.noonDt.toLocaleString(), mercury.r, compassY];
    } else {
      mercuryBall[d] = [suntime.southDt.toLocaleString(), mercury.r, compassY];
    }
  }

  // ここから水星SVG作成
  svg.groupId(`水星`);

  svg.groupId(`水星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`水星玉 ${mercuryBall[1][0]}`);
  svg.circle(svgAuR * mercuryBall[1][1], mercuryBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星玉 ${mercuryBall[d][0]}`);
    svg.circle(svgAuR * mercuryBall[d][1], mercuryBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`水星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星移動線 ${mercuryBall[d][0]}`);
    svg.line(svgAuR * mercuryBall[d - 1][1], mercuryBall[d - 1][2], svgAuR * mercuryBall[d][1], mercuryBall[d][2], svgLineWidth, blackColor);
    svg.groupFooter();
  }
  svg.groupId(`水星移動線 閉じる`);
  svg.line(svgAuR * mercuryBall[rotateDays][1], mercuryBall[rotateDays][2], svgAuR * mercuryBall[1][1], mercuryBall[1][2], svgLineWidth, blackColor);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`水星近点軌道`);
  svg.circle(0, 0, svgInR, svgLineWidth, redColor, `none`);
  svg.groupFooter();
  svg.groupId(`水星遠点軌道`);
  svg.circle(0, 0, svgOutR, svgLineWidth, redColor, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 金星
function drawVenus(o, flagDrawTime) {
  const svgInR = 304.611, svgOutR = 308.7921;
  const svgSize = 1.72;
  const strokeColor = '#231815';
  const rotateDays = 225;
  let drawDt;
  let suntime;
  let mjd, t;
  let venus;
  let venusBall = [];
  let compassY
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  venus = new Venus(t);

  // 金星玉
  compassY = venus.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    venusBall[1] = [suntime.noonDt.toLocaleString(), venus.r, compassY];
  } else {
    venusBall[1] = [suntime.southDt.toLocaleString(), venus.r, compassY];
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    venus = new Venus(t);

    // 金星玉
    compassY = venus.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      venusBall[d] = [suntime.noonDt.toLocaleString(), venus.r, compassY];
    } else {
      venusBall[d] = [suntime.southDt.toLocaleString(), venus.r, compassY];
    }
  }

  // ここから金星SVG作成
  svg.groupId(`金星`);

  svg.groupId(`金星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`金星玉 ${venusBall[1][0]}`);
  svg.circle(svgAuR * venusBall[1][1], venusBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星玉 ${venusBall[d][0]}`);
    svg.circle(svgAuR * venusBall[d][1], venusBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`金星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星移動線 ${venusBall[d][0]}`);
    svg.line(svgAuR * venusBall[d - 1][1], venusBall[d - 1][2], svgAuR * venusBall[d][1], venusBall[d][2], svgLineWidth, blackColor);
    svg.groupFooter();
  }
  svg.groupId(`金星移動線 閉じる`);
  svg.line(svgAuR * venusBall[rotateDays][1], venusBall[rotateDays][2], svgAuR * venusBall[1][1], venusBall[1][2], svgLineWidth, blackColor);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`金星近点軌道`);
  svg.circle(0, 0, svgInR, svgLineWidth, redColor, `none`);
  svg.groupFooter();
  svg.groupId(`金星遠点軌道`);
  svg.circle(0, 0, svgOutR, svgLineWidth, redColor, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 火星
function drawMars(o, flagDrawTime) {
  const svgInR = 585.71316, svgOutR = 706.40593;
  const svgSize = 0.96;
  const strokeColor = '#333333';
  const rotateDays = 687;
  let drawDt;
  let suntime;
  let mjd, t;
  let mars;
  let marsBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  mars = new Mars(t);

  // 火星玉
  compassY = mars.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }

  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    marsBall[1] = [suntime.noonDt.toLocaleString(), mars.r, compassY];
  } else {
    marsBall[1] = [suntime.southDt.toLocaleString(), mars.r, compassY];
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    mars = new Mars(t);

    // 火星玉
    compassY = mars.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      marsBall[d] = [suntime.noonDt.toLocaleString(), mars.r, compassY];
    } else {
      marsBall[d] = [suntime.southDt.toLocaleString(), mars.r, compassY];
    }
  }

  // ここから火星SVG作成
  svg.groupId(`火星`);

  svg.groupId(`火星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`火星玉 ${marsBall[1][0]}`);
  svg.circle(svgAuR * marsBall[1][1], marsBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星玉 ${marsBall[d][0]}`);
    svg.circle(svgAuR * marsBall[d][1], marsBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`火星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星移動線 ${marsBall[d][0]}`);
    svg.line(svgAuR * marsBall[d - 1][1], marsBall[d - 1][2], svgAuR * marsBall[d][1], marsBall[d][2], svgLineWidth, blackColor);
    svg.groupFooter();
  }
  svg.groupId(`火星移動線 閉じる`);
  svg.line(svgAuR * marsBall[rotateDays][1], marsBall[rotateDays][2], svgAuR * marsBall[1][1], marsBall[1][2], svgLineWidth, blackColor);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`火星近点軌道`);
  svg.circle(0, 0, svgInR, svgLineWidth, redColor, `none`);
  svg.groupFooter();
  svg.groupId(`火星遠点軌道`);
  svg.circle(0, 0, svgOutR, svgLineWidth, redColor, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 木星
function drawJupiter(o, flagDrawTime) {
  const svgR = 730.001;
  const svgSmallSize = 1.0023;
  const svgBigSize = 20.126;
  const strokeColor = '#333333';
  const rotateMonths = 12;
  const rotateYears = 12;
  let drawDt;
  let suntime;
  let mjd, t;
  let jupiter;
  let jupiterSmallBall = [], jupiterBigBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  jupiter = new Jupiter(t);

  // 木星玉・大
  compassY = jupiter.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    jupiterBigBall[1] = [suntime.noonDt.toLocaleString(), svgR, compassY];
  } else {
    jupiterBigBall[1] = [suntime.southDt.toLocaleString(), svgR, compassY];
  }

  // 1年後までの要素ループ
  // 翌月1日から毎月1日を描画
  drawDt.setDate(1);

  for (d = 1; d <= rotateMonths; d++) {
    drawDt.setMonth(drawDt.getMonth() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    jupiter = new Jupiter(t);

    // 木星玉・小
    compassY = jupiter.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }

    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      jupiterSmallBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      jupiterSmallBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // 1年後から最終までの要素ループ
  drawDt = new Date(o.initDt);
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setYear(drawDt.getFullYear() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    jupiter = new Jupiter(t);

    // 木星玉・大
    compassY = jupiter.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      jupiterBigBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      jupiterBigBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // ここから木星SVG作成
  svg.groupId(`木星`);

  svg.groupId(`木星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`木星玉・大 ${jupiterBigBall[1][0]}`);
  svg.circle(jupiterBigBall[1][1], jupiterBigBall[1][2], svgBigSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 1; d <= rotateMonths; d++) {
    svg.groupId(`木星玉・小 ${jupiterSmallBall[d][0]}`);
    svg.circle(jupiterSmallBall[d][1], jupiterSmallBall[d][2], svgSmallSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`木星玉・大 ${jupiterBigBall[d][0]}`);
    svg.circle(jupiterBigBall[d][1], jupiterBigBall[d][2], svgBigSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`木星軌道線`);
  svg.groupId(`木星移動線 ${jupiterSmallBall[1][0]}`);
  svg.arc(jupiterBigBall[1][1], jupiterBigBall[1][2], jupiterSmallBall[1][1], jupiterSmallBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();

  for (d = 2; d <= rotateMonths; d++) {
    svg.groupId(`木星移動線 ${jupiterSmallBall[d][0]}`);
    svg.arc(jupiterSmallBall[d - 1][1], jupiterSmallBall[d - 1][2], jupiterSmallBall[d][1], jupiterSmallBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }

  svg.groupId(`木星移動線 ${jupiterBigBall[2][0]}`);
  svg.arc(jupiterSmallBall[rotateMonths][1], jupiterSmallBall[rotateMonths][2], jupiterBigBall[2][1], jupiterBigBall[2][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();

  for (d = 3; d <= rotateYears; d++) {
    svg.groupId(`木星移動線 ${jupiterBigBall[d][0]}`);
    svg.arc(jupiterBigBall[d - 1][1], jupiterBigBall[d - 1][2], jupiterBigBall[d][1], jupiterBigBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }

  svg.groupId(`木星移動線 閉じる`);
  svg.arc(jupiterBigBall[rotateYears][1], jupiterBigBall[rotateYears][2], jupiterBigBall[1][1], jupiterBigBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 土星
function drawSaturn(o, flagDrawTime) {
  const svgR = 766.667;
  const svgSmallSize = 1.0023;
  const svgBigSize = 17.0088;
  const strokeColor = '#333333';
  const rotateMonths = 12;
  const rotateYears = 30;
  let drawDt;
  let suntime;
  let mjd, t;
  let saturn;
  let saturnSmallBall = [], saturnBigBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  saturn = new Saturn(t);

  // 土星玉・大
  compassY = saturn.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    saturnBigBall[1] = [suntime.noonDt.toLocaleString(), svgR, compassY];
  } else {
    saturnBigBall[1] = [suntime.southDt.toLocaleString(), svgR, compassY];
  }

  // 1年後までの要素ループ
  // 翌月1日から毎月1日を描画
  drawDt.setDate(1);

  for (d = 1; d <= rotateMonths; d++) {
    drawDt.setMonth(drawDt.getMonth() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    saturn = new Saturn(t);

    // 土星玉・小
    compassY = saturn.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      saturnSmallBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      saturnSmallBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // 1年後から最終までの要素ループ
  drawDt = new Date(o.initDt);
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setYear(drawDt.getFullYear() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    saturn = new Saturn(t);

    // 土星玉・大
    compassY = saturn.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      saturnBigBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      saturnBigBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // ここから土星SVG作成
  svg.groupId(`土星`);

  svg.groupId(`土星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`土星玉・大 ${saturnBigBall[1][0]}`);
  svg.circle(saturnBigBall[1][1], saturnBigBall[1][2], svgBigSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 1; d <= rotateMonths; d++) {
    svg.groupId(`土星玉・小 ${saturnSmallBall[d][0]}`);
    svg.circle(saturnSmallBall[d][1], saturnSmallBall[d][2], svgSmallSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`土星玉・大 ${saturnBigBall[d][0]}`);
    svg.circle(saturnBigBall[d][1], saturnBigBall[d][2], svgBigSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`土星軌道線`);
  svg.groupId(`土星移動線 ${saturnSmallBall[1][0]}`);
  svg.arc(saturnBigBall[1][1], saturnBigBall[1][2], saturnSmallBall[1][1], saturnSmallBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();

  for (d = 2; d <= rotateMonths; d++) {
    svg.groupId(`土星移動線 ${saturnSmallBall[d][0]}`);
    svg.arc(saturnSmallBall[d - 1][1], saturnSmallBall[d - 1][2], saturnSmallBall[d][1], saturnSmallBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }

  svg.groupId(`土星移動線 ${saturnBigBall[2][0]}`);
  svg.arc(saturnSmallBall[rotateMonths][1], saturnSmallBall[rotateMonths][2], saturnBigBall[2][1], saturnBigBall[2][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();

  for (d = 3; d <= rotateYears; d++) {
    svg.groupId(`土星移動線 ${saturnBigBall[d][0]}`);
    svg.arc(saturnBigBall[d - 1][1], saturnBigBall[d - 1][2], saturnBigBall[d][1], saturnBigBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }

  svg.groupId(`土星移動線 閉じる`);
  svg.arc(saturnBigBall[rotateYears][1], saturnBigBall[rotateYears][2], saturnBigBall[1][1], saturnBigBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 天王星
function drawUranus(o, flagDrawTime) {
  const svgR = 792.667;
  const svgSize = 7.3696;
  const strokeColor = '#333333';
  const rotateYears = 86;
  let drawDt;
  let suntime;
  let mjd, t;
  let uranus;
  let uranusBall = [];
  let compassY
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  uranus = new Uranus(t);

  // 天王星玉
  compassY = uranus.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    uranusBall[1] = [suntime.noonDt.toLocaleString(), svgR, compassY];
  } else {
    uranusBall[1] = [suntime.southDt.toLocaleString(), svgR, compassY];
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    uranus = new Uranus(t);

    // 天王星玉
    compassY = uranus.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      uranusBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      uranusBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // ここから天王星SVG作成
  svg.groupId(`天王星`);

  svg.groupId(`天王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`天王星玉 ${uranusBall[1][0]}`);
  svg.circle(uranusBall[1][1], uranusBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`天王星玉 ${uranusBall[d][0]}`);
    svg.circle(uranusBall[d][1], uranusBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`天王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`天王星移動線 ${uranusBall[d][0]}`);
    svg.arc(uranusBall[d - 1][1], uranusBall[d - 1][2], uranusBall[d][1], uranusBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }
  svg.groupId(`天王星移動線 閉じる`);
  svg.arc(uranusBall[rotateYears][1], uranusBall[rotateYears][2], uranusBall[1][1], uranusBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 海王星
function drawNeptune(o, flagDrawTime) {
  const svgR = 806.001;
  const svgSize = 7.0859;
  const strokeColor = '#333333';
  const rotateYears = 164;
  let drawDt;
  let suntime;
  let mjd, t;
  let neptune;
  let neptuneBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  neptune = new Neptune(t);

  // 海王星玉
  compassY = neptune.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    neptuneBall[1] = [suntime.noonDt.toLocaleString(), svgR, compassY];
  } else {
    neptuneBall[1] = [suntime.southDt.toLocaleString(), svgR, compassY];
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    neptune = new Neptune(t);

    // 海王星玉
    compassY = neptune.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      neptuneBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      neptuneBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // ここから海王星SVG作成
  svg.groupId(`海王星`);

  svg.groupId(`海王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`海王星玉 ${neptuneBall[1][0]}`);
  svg.circle(neptuneBall[1][1], neptuneBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`海王星玉 ${neptuneBall[d][0]}`);
    svg.circle(neptuneBall[d][1], neptuneBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`海王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`海王星移動線 ${neptuneBall[d][0]}`);
    svg.arc(neptuneBall[d - 1][1], neptuneBall[d - 1][2], neptuneBall[d][1], neptuneBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }
  svg.groupId(`海王星移動線 閉じる`);
  svg.arc(neptuneBall[rotateYears][1], neptuneBall[rotateYears][2], neptuneBall[1][1], neptuneBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 冥王星
function drawPluto(o, flagDrawTime) {
  const svgR = 818.667;
  const svgSize = 0.2832;
  const strokeColor = '#333333';
  const rotateYears = 219;
  let drawDt;
  let suntime;
  let mjd, t;
  let pluto;
  let plutoBall = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(o.initDt);
  suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = Astro.mjd(suntime.noonDt, o.timezone);
  } else {
    mjd = Astro.mjd(suntime.southDt, o.timezone);
  }
  t = Astro.t(mjd);
  pluto = new Pluto(t);

  // 冥王星玉
  compassY = pluto.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    plutoBall[1] = [suntime.noonDt.toLocaleString(), svgR, compassY];
  } else {
    plutoBall[1] = [suntime.southDt.toLocaleString(), svgR, compassY];
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new Suntime(drawDt, o.longitude, o.latitude, o.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = Astro.mjd(suntime.noonDt, o.timezone);
    } else {
      mjd = Astro.mjd(suntime.southDt, o.timezone);
    }
    t = Astro.t(mjd);
    pluto = new Pluto(t);

    // 冥王星玉
    compassY = pluto.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      plutoBall[d] = [suntime.noonDt.toLocaleString(), svgR, compassY];
    } else {
      plutoBall[d] = [suntime.southDt.toLocaleString(), svgR, compassY];
    }
  }

  // ここから冥王星SVG作成
  svg.groupId(`冥王星`);

  svg.groupId(`冥王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`冥王星玉 ${plutoBall[1][0]}`);
  svg.circle(plutoBall[1][1], plutoBall[1][2], svgSize, svgLineWidth, greenColor, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`冥王星玉 ${plutoBall[d][0]}`);
    svg.circle(plutoBall[d][1], plutoBall[d][2], svgSize, svgLineWidth, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`冥王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`冥王星移動線 ${plutoBall[d][0]}`);
    svg.arc(plutoBall[d - 1][1], plutoBall[d - 1][2], plutoBall[d][1], plutoBall[d][2], svgR, svgLineWidth, redColor, 'none');
    svg.groupFooter();
  }
  svg.groupId(`冥王星移動線 閉じる`);
  svg.arc(plutoBall[rotateYears][1], plutoBall[rotateYears][2], plutoBall[1][1], plutoBall[1][2], svgR, svgLineWidth, redColor, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}
